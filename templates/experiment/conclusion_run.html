{% extends "base.html" %}

{% block title %}Run Conclusion Prediction Experiment{% endblock %}

{% block head %}
{{ super() }}
<style>
  .experiment-run-container {
    max-width: 900px;
    margin: 0 auto;
    padding: 20px;
  }
  .experiment-details {
    margin-bottom: 30px;
    padding: 15px;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    background-color: #f8f9fa;
  }
  .progress-section {
    margin-bottom: 30px;
  }
  .case-progress-container {
    margin-top: 20px;
  }
  .case-card {
    margin-bottom: 15px;
    padding: 15px;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    background-color: white;
  }
  .case-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
  }
  .case-progress {
    margin-bottom: 10px;
  }
  .case-status {
    font-size: 0.9em;
    margin-top: 5px;
  }
  .status-pending {
    color: #6c757d;
  }
  .status-processing {
    color: #007bff;
  }
  .status-completed {
    color: #28a745;
  }
  .status-failed {
    color: #dc3545;
  }
  .timer-container {
    margin-top: 15px;
    text-align: center;
    font-size: 1.2em;
  }
  .estimation-container {
    margin-top: 15px;
    text-align: center;
    font-size: 0.9em;
    color: #6c757d;
  }
  .footer-actions {
    margin-top: 30px;
    display: flex;
    justify-content: space-between;
  }
  .alert-processing {
    background-color: #e3f2fd;
    border-color: #b6d4fe;
    color: #0a58ca;
  }
  .log-container {
    height: 200px;
    overflow-y: auto;
    background-color: #f8f9fa;
    border: 1px solid #dee2e6;
    border-radius: 4px;
    padding: 10px;
    font-family: monospace;
    font-size: 0.9em;
    margin-top: 20px;
  }
  .log-entry {
    margin-bottom: 5px;
    padding: 2px 0;
    border-bottom: 1px dotted #dee2e6;
  }
  .log-entry-time {
    color: #6c757d;
    margin-right: 5px;
  }
  .log-entry-info {
    color: #0a58ca;
  }
  .log-entry-warning {
    color: #fd7e14;
  }
  .log-entry-error {
    color: #dc3545;
  }
</style>
{% endblock %}

{% block content %}
<div class="experiment-run-container">
  <h1>Run Conclusion Prediction Experiment</h1>
  
  <div class="experiment-details">
    <h3>{{ experiment.name }}</h3>
    <p>{{ experiment.description }}</p>
    <div class="experiment-meta">
      <span class="badge badge-primary">Created: {{ experiment.created_at.strftime('%Y-%m-%d %H:%M') }}</span>
      <span class="badge badge-info ml-2">Status: {{ experiment.status }}</span>
      <span class="badge badge-secondary ml-2">Cases: {{ selected_cases|length }}</span>
    </div>
  </div>
  
  <div class="alert alert-processing" role="alert" id="processing-alert">
    <h4 class="alert-heading">Processing!</h4>
    <p>The experiment is currently running. Please do not close this page until processing is complete.</p>
    <hr>
    <p class="mb-0">Predictions are being generated using both baseline and ProEthica enhanced methods.</p>
  </div>
  
  <div class="progress-section">
    <h3>Overall Progress</h3>
    <div class="progress" style="height: 25px;">
      <div class="progress-bar progress-bar-striped progress-bar-animated" role="progressbar" id="overall-progress-bar" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
    </div>
    
    <div class="timer-container">
      <span>Elapsed Time: <span id="elapsed-time">00:00:00</span></span>
    </div>
    
    <div class="estimation-container">
      <span>Estimated Time Remaining: <span id="estimated-time">Calculating...</span></span>
    </div>
  </div>
  
  <div class="case-progress-container">
    <h3>Case Progress</h3>
    
    {% for case in selected_cases %}
    <div class="case-card" id="case-card-{{ case.id }}">
      <div class="case-header">
        <h5>{{ case.title }}</h5>
        <span class="case-status status-pending" id="case-status-{{ case.id }}">Pending</span>
      </div>
      <div class="progress case-progress">
        <div class="progress-bar" role="progressbar" id="case-progress-{{ case.id }}" style="width: 0%;" aria-valuenow="0" aria-valuemin="0" aria-valuemax="100">0%</div>
      </div>
      <div class="case-time" id="case-time-{{ case.id }}">
        <!-- Case timing information will be inserted here -->
      </div>
    </div>
    {% endfor %}
  </div>
  
  <div class="log-section">
    <h3>Processing Log</h3>
    <div class="log-container" id="log-container">
      <div class="log-entry">
        <span class="log-entry-time">{{ now().strftime('%H:%M:%S') }}</span>
        <span class="log-entry-info">Experiment started</span>
      </div>
    </div>
  </div>
  
  <div class="footer-actions">
    <button class="btn btn-light" id="cancel-button" onclick="cancelExperiment()">Cancel Experiment</button>
    <button class="btn btn-primary" id="view-results-button" onclick="location.href='{{ url_for('experiment.view_results', experiment_id=experiment.id) }}'" disabled>View Results</button>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    const caseIds = [{% for case in selected_cases %}{{ case.id }}{% if not loop.last %},{% endif %}{% endfor %}];
    const startTime = new Date();
    let completedCases = 0;
    let intervalId;
    
    // Start the experiment
    startExperiment();
    
    // Start timer
    intervalId = setInterval(updateTimer, 1000);
    
    // Function to start the experiment
    function startExperiment() {
      // Add initial log entry
      addLogEntry('Starting experiment with ' + caseIds.length + ' cases', 'info');
      
      // Process cases sequentially
      processNextCase(0);
    }
    
    // Process the next case in the queue
    function processNextCase(index) {
      if (index >= caseIds.length) {
        // All cases processed
        experimentCompleted();
        return;
      }
      
      const caseId = caseIds[index];
      
      // Update UI to show this case is processing
      document.getElementById('case-status-' + caseId).textContent = 'Processing';
      document.getElementById('case-status-' + caseId).className = 'case-status status-processing';
      
      // Log the start of case processing
      addLogEntry('Processing case #' + caseId + ': ' + document.querySelector('#case-card-' + caseId + ' h5').textContent, 'info');
      
      // Make AJAX request to process the case
      fetch('{{ url_for('experiment.process_case') }}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          experiment_id: {{ experiment.id }},
          case_id: caseId
        })
      })
      .then(response => response.json())
      .then(data => {
        // Update UI based on the result
        document.getElementById('case-progress-' + caseId).style.width = '100%';
        document.getElementById('case-progress-' + caseId).textContent = '100%';
        
        if (data.success) {
          // Case processed successfully
          document.getElementById('case-status-' + caseId).textContent = 'Completed';
          document.getElementById('case-status-' + caseId).className = 'case-status status-completed';
          document.getElementById('case-time-' + caseId).textContent = 'Processed in ' + data.processing_time + ' seconds';
          addLogEntry('Case #' + caseId + ' completed successfully', 'info');
        } else {
          // Case processing failed
          document.getElementById('case-status-' + caseId).textContent = 'Failed';
          document.getElementById('case-status-' + caseId).className = 'case-status status-failed';
          addLogEntry('Case #' + caseId + ' failed: ' + data.error, 'error');
        }
        
        // Update overall progress
        completedCases++;
        updateOverallProgress();
        
        // Process the next case
        setTimeout(() => processNextCase(index + 1), 1000);
      })
      .catch(error => {
        // Error in processing case
        document.getElementById('case-status-' + caseId).textContent = 'Failed';
        document.getElementById('case-status-' + caseId).className = 'case-status status-failed';
        addLogEntry('Error processing case #' + caseId + ': ' + error, 'error');
        
        // Update overall progress
        completedCases++;
        updateOverallProgress();
        
        // Continue with next case despite error
        setTimeout(() => processNextCase(index + 1), 1000);
      });
      
      // Simulated progress updates (since the actual processing happens on the server)
      simulateProgress(caseId);
    }
    
    // Simulate progress updates for a case
    function simulateProgress(caseId) {
      let progress = 0;
      const progressBar = document.getElementById('case-progress-' + caseId);
      
      const progressInterval = setInterval(function() {
        progress += Math.random() * 10;
        
        if (progress >= 100) {
          progress = 99; // Stop just short of 100% until the server confirms completion
          clearInterval(progressInterval);
        }
        
        progress = Math.min(progress, 99);
        const width = Math.floor(progress) + '%';
        progressBar.style.width = width;
        progressBar.textContent = width;
        progressBar.setAttribute('aria-valuenow', Math.floor(progress));
      }, 2000);
    }
    
    // Update overall progress
    function updateOverallProgress() {
      const percentage = (completedCases / caseIds.length) * 100;
      const progressBar = document.getElementById('overall-progress-bar');
      progressBar.style.width = percentage + '%';
      progressBar.textContent = Math.floor(percentage) + '%';
      progressBar.setAttribute('aria-valuenow', Math.floor(percentage));
      
      // Update estimated time remaining
      updateEstimatedTime(percentage);
      
      // Check if experiment is complete
      if (completedCases >= caseIds.length) {
        experimentCompleted();
      }
    }
    
    // Update timer
    function updateTimer() {
      const now = new Date();
      const elapsedTime = Math.floor((now - startTime) / 1000);
      document.getElementById('elapsed-time').textContent = formatTime(elapsedTime);
    }
    
    // Update estimated time remaining
    function updateEstimatedTime(percentage) {
      if (percentage <= 0) return;
      
      const now = new Date();
      const elapsedSeconds = Math.floor((now - startTime) / 1000);
      const totalSecondsEstimate = (elapsedSeconds / percentage) * 100;
      const remainingSeconds = Math.max(0, totalSecondsEstimate - elapsedSeconds);
      
      document.getElementById('estimated-time').textContent = formatTime(remainingSeconds);
    }
    
    // Format time in HH:MM:SS
    function formatTime(totalSeconds) {
      const hours = Math.floor(totalSeconds / 3600);
      const minutes = Math.floor((totalSeconds % 3600) / 60);
      const seconds = totalSeconds % 60;
      
      return String(hours).padStart(2, '0') + ':' +
             String(minutes).padStart(2, '0') + ':' +
             String(seconds).padStart(2, '0');
    }
    
    // Add log entry
    function addLogEntry(message, level) {
      const logContainer = document.getElementById('log-container');
      const now = new Date();
      
      const entry = document.createElement('div');
      entry.className = 'log-entry';
      
      const timeSpan = document.createElement('span');
      timeSpan.className = 'log-entry-time';
      timeSpan.textContent = now.getHours().toString().padStart(2, '0') + ':' +
                           now.getMinutes().toString().padStart(2, '0') + ':' +
                           now.getSeconds().toString().padStart(2, '0');
      
      const messageSpan = document.createElement('span');
      messageSpan.className = 'log-entry-' + level;
      messageSpan.textContent = message;
      
      entry.appendChild(timeSpan);
      entry.appendChild(document.createTextNode(' '));
      entry.appendChild(messageSpan);
      
      logContainer.appendChild(entry);
      
      // Auto-scroll to bottom
      logContainer.scrollTop = logContainer.scrollHeight;
    }
    
    // Experiment completed
    function experimentCompleted() {
      addLogEntry('Experiment completed!', 'info');
      
      // Show completion alert
      document.getElementById('processing-alert').className = 'alert alert-success';
      document.getElementById('processing-alert').innerHTML = `
        <h4 class="alert-heading">Completed!</h4>
        <p>The experiment has been successfully completed.</p>
        <hr>
        <p class="mb-0">You can now view the results.</p>`;
      
      // Enable view results button
      document.getElementById('view-results-button').disabled = false;
      
      // Disable cancel button
      document.getElementById('cancel-button').disabled = true;
      
      // Stop the timer
      clearInterval(intervalId);
      
      // Update experiment status via AJAX
      fetch('{{ url_for('experiment.update_status') }}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          experiment_id: {{ experiment.id }},
          status: 'completed'
        })
      });
    }
    
    // Cancel experiment
    window.cancelExperiment = function() {
      if (!confirm('Are you sure you want to cancel this experiment?')) return;
      
      // Update experiment status via AJAX
      fetch('{{ url_for('experiment.update_status') }}', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          experiment_id: {{ experiment.id }},
          status: 'cancelled'
        })
      })
      .then(response => response.json())
      .then(data => {
        if (data.success) {
          // Redirect to experiments list
          window.location.href = "{{ url_for('experiment.index') }}";
        } else {
          addLogEntry('Failed to cancel experiment: ' + data.error, 'error');
        }
      });
    };
  });
