#!/usr/bin/env python
"""
Demo script for executing SPARQL-like queries against the entity_triples table.
This script demonstrates how to perform complex queries across different entity types
in the context of engineering ethics.
"""

import os
import sys
import json
from datetime import datetime
from pprint import pprint
from sqlalchemy import text

# Add the parent directory to the path so we can import the app
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from app import create_app, db

class EntityGraphQueryService:
    """
    Service for executing SPARQL-like queries against the entity_triples table.
    This service provides simplified graph query capabilities using SQL.
    """
    
    def __init__(self, db_session=None):
        self.session = db_session or db.session
    
    def find_by_type(self, entity_type, scenario_id=None, limit=10):
        """Find entities of a specific type."""
        query = """
        SELECT DISTINCT subject, e.entity_id
        FROM entity_triples e
        WHERE predicate = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
        AND object_uri = :type_uri
        """
        
        if scenario_id:
            query += " AND e.scenario_id = :scenario_id"
            
        query += " LIMIT :limit"
        
        result = self.session.execute(text(query), {
            'type_uri': f'http://proethica.org/ontology/{entity_type}',
            'scenario_id': scenario_id,
            'limit': limit
        })
        
        return [dict(row) for row in result]
    
    def find_professional_engineers(self, scenario_id=None):
        """Find all professional engineers in a scenario."""
        query = """
        SELECT c.id, c.name, c.attributes, t.subject AS uri
        FROM characters c
        JOIN entity_triples t ON t.entity_type = 'character' AND t.entity_id = c.id
        WHERE t.predicate = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
        AND t.object_uri = 'http://proethica.org/ontology/engineering-ethics#ProfessionalEngineer'
        """
        
        if scenario_id:
            query += " AND c.scenario_id = :scenario_id"
            
        result = self.session.execute(text(query), {'scenario_id': scenario_id})
        return [dict(row) for row in result]
    
    def find_ethical_decisions(self, scenario_id=None, limit=10):
        """Find all ethical decisions in a scenario."""
        query = """
        SELECT 
            a.id AS decision_id, 
            a.name AS decision_name, 
            a.description,
            c.name AS character_name,
            a.selected_option,
            t.subject AS uri
        FROM actions a
        JOIN entity_triples t ON t.entity_type = 'action' AND t.entity_id = a.id
        LEFT JOIN characters c ON a.character_id = c.id
        WHERE t.predicate = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
        AND t.object_uri = 'http://proethica.org/ontology/Decision'
        AND a.is_decision = TRUE
        """
        
        if scenario_id:
            query += " AND a.scenario_id = :scenario_id"
            
        query += " LIMIT :limit"
            
        result = self.session.execute(text(query), {
            'scenario_id': scenario_id,
            'limit': limit
        })
        
        return [dict(row) for row in result]
    
    def find_decision_ethical_principles(self, decision_id):
        """Find ethical principles invoked by a decision."""
        query = """
        SELECT 
            t.object_uri AS principle_uri,
            t.predicate AS relationship
        FROM entity_triples t
        WHERE t.entity_type = 'action'
        AND t.entity_id = :decision_id
        AND t.is_literal = FALSE
        AND (
            t.predicate = 'http://proethica.org/ontology/invokes' OR
            t.predicate = 'http://proethica.org/ontology/hasOntologyReference'
        )
        """
        
        result = self.session.execute(text(query), {'decision_id': decision_id})
        return [dict(row) for row in result]
    
    def find_character_decisions(self, character_id):
        """Find all decisions made by a character."""
        query = """
        SELECT 
            a.id AS decision_id,
            a.name AS decision_name,
            a.description,
            a.selected_option,
            a.action_time,
            t.subject AS uri
        FROM actions a
        JOIN entity_triples t ON t.entity_type = 'action' AND t.entity_id = a.id
        WHERE a.character_id = :character_id
        AND a.is_decision = TRUE
        ORDER BY a.action_time
        """
        
        result = self.session.execute(text(query), {'character_id': character_id})
        return [dict(row) for row in result]
    
    def find_events_related_to_decision(self, decision_id):
        """Find events generated by a decision."""
        query = """
        SELECT 
            e.id AS event_id,
            e.description,
            e.event_time,
            t.subject AS decision_uri,
            t.object_uri AS event_uri
        FROM events e
        JOIN entity_triples t ON 
            t.entity_type = 'action' AND 
            t.entity_id = :decision_id AND
            t.object_uri LIKE 'http://proethica.org/event/%'
        WHERE e.action_id = :decision_id
        ORDER BY e.event_time
        """
        
        result = self.session.execute(text(query), {'decision_id': decision_id})
        return [dict(row) for row in result]
    
    def find_path_between_entities(self, start_uri, end_uri, max_depth=5):
        """Find paths between two entities."""
        query = """
        SELECT * FROM get_entity_paths(:start_uri, :end_uri, :max_depth)
        """
        
        result = self.session.execute(text(query), {
            'start_uri': start_uri,
            'end_uri': end_uri,
            'max_depth': max_depth
        })
        
        return [dict(row) for row in result]
    
    def find_decisions_violating_principles(self, principle_uri=None):
        """Find decisions that violate ethical principles."""
        query = """
        SELECT 
            a.id AS decision_id,
            a.name AS decision_name,
            c.name AS character_name,
            t.object_uri AS principle_uri
        FROM actions a
        JOIN entity_triples t ON t.entity_type = 'action' AND t.entity_id = a.id
        LEFT JOIN characters c ON a.character_id = c.id
        WHERE t.predicate = 'http://proethica.org/ontology/violates'
        AND t.is_literal = FALSE
        """
        
        if principle_uri:
            query += " AND t.object_uri = :principle_uri"
            
        result = self.session.execute(text(query), {'principle_uri': principle_uri})
        return [dict(row) for row in result]
    
    def semantic_search(self, query_text, entity_type=None, threshold=0.7, limit=10):
        """
        Perform semantic search using vector embeddings.
        This is a placeholder for the actual implementation that would use pgvector.
        """
        # This would need embedding_service to get the embedding for query_text
        # Then use cosine similarity to find similar embeddings
        
        print(f"Semantic search for: '{query_text}'")
        print(f"Entity type filter: {entity_type or 'any'}")
        print(f"Similarity threshold: {threshold}")
        
        # Mock results for demonstration
        if "safety" in query_text.lower():
            return [
                {
                    "subject": "http://proethica.org/action/42",
                    "label": "Bridge Safety Reporting Decision",
                    "entity_type": "action",
                    "entity_id": 42,
                    "similarity": 0.92
                },
                {
                    "subject": "http://proethica.org/event/55",
                    "label": "Bridge foundation safety concerns reported to authorities",
                    "entity_type": "event",
                    "entity_id": 55,
                    "similarity": 0.85
                }
            ]
        
        elif "engineer" in query_text.lower() or "professional" in query_text.lower():
            return [
                {
                    "subject": "http://proethica.org/character/20_jane_smith",
                    "label": "Jane Smith",
                    "entity_type": "character",
                    "entity_id": 33,
                    "similarity": 0.89
                }
            ]
            
        # Default empty result
        return []


def demo_basic_queries(app):
    """Demo basic entity queries."""
    with app.app_context():
        print("\n=== Basic Entity Queries ===")
        
        service = EntityGraphQueryService()
        
        # Find all decisions
        print("\n1. Finding all decision entities:")
        decisions = service.find_by_type("Decision")
        print(f"Found {len(decisions)} decisions")
        for i, decision in enumerate(decisions[:3]):
            print(f"  {i+1}. {decision['subject']} (ID: {decision['entity_id']})")
        
        # Find professional engineers
        print("\n2. Finding all professional engineers:")
        engineers = service.find_professional_engineers()
        print(f"Found {len(engineers)} professional engineers")
        for i, engineer in enumerate(engineers[:3]):
            print(f"  {i+1}. {engineer['name']} (ID: {engineer['id']})")
            if 'attributes' in engineer and engineer['attributes']:
                print(f"     Years of experience: {engineer['attributes'].get('yearsOfExperience', 'Unknown')}")
                print(f"     Specialization: {engineer['attributes'].get('specialization', 'Unknown')}")


def demo_ethical_decision_queries(app):
    """Demo ethical decision-specific queries."""
    with app.app_context():
        print("\n=== Ethical Decision Queries ===")
        
        service = EntityGraphQueryService()
        
        # Find all ethical decisions
        print("\n1. Finding ethical decisions:")
        decisions = service.find_ethical_decisions()
        print(f"Found {len(decisions)} ethical decisions")
        
        # If no decisions found in the demo, provide a mock example
        if not decisions:
            decisions = [{
                "decision_id": 42,
                "decision_name": "Bridge Safety Reporting Decision",
                "description": "Decision on whether to report safety concerns about the bridge foundation",
                "character_name": "Jane Smith",
                "selected_option": "option1",
                "uri": "http://proethica.org/action/42"
            }]
        
        for i, decision in enumerate(decisions[:3]):
            print(f"  {i+1}. {decision['decision_name']} by {decision['character_name']}")
            print(f"     Selected: {decision['selected_option']}")
            
            # Find ethical principles for this decision
            principles = service.find_decision_ethical_principles(decision['decision_id'])
            if principles:
                print(f"     Related ethical principles:")
                for j, principle in enumerate(principles):
                    print(f"       - {principle['principle_uri']} ({principle['relationship']})")
            
            # Find events resulting from this decision
            events = service.find_events_related_to_decision(decision['decision_id'])
            if events:
                print(f"     Resulting events:")
                for j, event in enumerate(events):
                    print(f"       - {event['description']} at {event['event_time']}")


def demo_path_queries(app):
    """Demo path finding between entities."""
    with app.app_context():
        print("\n=== Entity Path Queries ===")
        
        service = EntityGraphQueryService()
        
        # Define example URIs for the demo
        character_uri = "http://proethica.org/character/20_jane_smith"
        decision_uri = "http://proethica.org/action/42"
        event_uri = "http://proethica.org/event/55"
        
        # Find path from character to event
        print("\n1. Finding path from character to event:")
        paths = service.find_path_between_entities(character_uri, event_uri)
        
        # If no paths found in the demo, provide a mock example
        if not paths:
            paths = [{
                "path": [
                    "http://proethica.org/character/20_jane_smith",
                    "http://proethica.org/action/42",
                    "http://proethica.org/event/55"
                ],
                "path_predicates": [
                    "http://proethica.org/ontology/performs",
                    "http://proethica.org/ontology/generates"
                ],
                "depth": 3
            }]
        
        for i, path in enumerate(paths[:3]):
            print(f"  Path {i+1} (depth {path['depth']}):")
            for j in range(len(path['path']) - 1):
                print(f"    {path['path'][j]} --[{path['path_predicates'][j]}]--> {path['path'][j+1]}")


def demo_semantic_search(app):
    """Demo semantic search using vector embeddings."""
    with app.app_context():
        print("\n=== Semantic Search Queries ===")
        
        service = EntityGraphQueryService()
        
        # Search for safety-related entities
        print("\n1. Searching for 'public safety concerns in engineering':")
        results = service.semantic_search("public safety concerns in engineering")
        
        for i, result in enumerate(results):
            print(f"  {i+1}. {result['label']} ({result['entity_type']})")
            print(f"     URI: {result['subject']}")
            print(f"     Similarity: {result['similarity']:.2f}")
        
        # Search for professional engineers with ethical concerns
        print("\n2. Searching for 'professional engineer with ethical dilemma':")
        results = service.semantic_search("professional engineer with ethical dilemma")
        
        for i, result in enumerate(results):
            print(f"  {i+1}. {result['label']} ({result['entity_type']})")
            print(f"     URI: {result['subject']}")
            print(f"     Similarity: {result['similarity']:.2f}")


def main():
    """Run the entity triple query demonstrations."""
    app = create_app()
    
    print("=== Entity Triple Query Demonstrations ===")
    print("""
This script demonstrates how to perform SPARQL-like queries against
the entity_triples table, focusing on engineering ethics examples.

Note: These demonstrations simulate the queries that would be possible
with the entity_triples table. In a real implementation, the queries
would be executed against the actual database.
""")
    
    # Run the demonstrations
    demo_basic_queries(app)
    demo_ethical_decision_queries(app)
    demo_path_queries(app)
    demo_semantic_search(app)
    
    print("\n=== Demonstrations Completed ===")
    print("""
To implement these queries in the actual application:

1. Create the entity_triples table using scripts/create_entity_triples_table.sql
2. Implement the EntityGraphQueryService as shown in this demonstration
3. Extend the service with additional specialized queries
4. Integrate vector similarity search using pgvector

This approach provides powerful graph query capabilities while maintaining
the advantages of pgvector for semantic search.
""")


if __name__ == "__main__":
    main()
