"""
World Entity Integration
-----------------------
Integrates entities identified in cases with the world ontology.

This module:
1. Extracts entities from semantic triples generated by the tagger
2. Checks if they exist in the associated world
3. Adds new entities to the world if they don't exist
4. Creates proper associations between cases and world entities
"""

import logging
import json
from datetime import datetime
import sys
import os

# Add parent directory to path to import from app
sys.path.insert(0, os.path.abspath(os.path.dirname(os.path.dirname(os.path.dirname(__file__)))))
from app.services.application_context_service import ApplicationContextService
from app.models.world import World
from app.utils.ontology_utils import add_entity_to_ontology

# Set up logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(name)s - %(levelname)s - %(message)s')
logger = logging.getLogger("world_entity_integration")

class WorldEntityIntegrator:
    """Integrates entities from cases into world ontology."""
    
    def __init__(self):
        """Initialize the integrator with necessary services."""
        self.app_context = ApplicationContextService()
        
    def integrate_case_entities(self, case_id, world_id=None, triples=None):
        """
        Integrate entities from a case into its associated world.
        
        Args:
            case_id: ID of the case
            world_id: Optional ID of the world to integrate with
                      (if not provided, will use the world associated with the case)
            triples: Optional list of entity triples (if not provided, will fetch from the case)
            
        Returns:
            dict: Result of the integration process
        """
        try:
            # Step 1: Get the case and its world
            if not world_id:
                # Fetch case to get associated world
                case = self.app_context.get_case(case_id)
                if not case:
                    return {
                        'success': False,
                        'message': f"Case with ID {case_id} not found"
                    }
                    
                world_id = case.get('world_id')
                if not world_id:
                    return {
                        'success': False,
                        'message': f"Case with ID {case_id} is not associated with any world"
                    }
            
            # Step 2: Get the world and its ontology
            world = self.app_context.get_world(world_id)
            if not world:
                return {
                    'success': False,
                    'message': f"World with ID {world_id} not found"
                }
                
            ontology_id = world.get('ontology_id')
            if not ontology_id:
                return {
                    'success': False,
                    'message': f"World with ID {world_id} has no associated ontology"
                }
                
            # Step 3: Get the entity triples if not provided
            if not triples:
                # Fetch triples from the case
                triples = self.app_context.get_entity_triples(case_id)
                
            if not triples:
                return {
                    'success': False,
                    'message': f"No entity triples found for case ID {case_id}"
                }
                
            # Step 4: Extract entities from triples
            entities = self._extract_entities_from_triples(triples)
            if not entities:
                return {
                    'success': True,
                    'message': "No new entities to integrate",
                    'case_id': case_id,
                    'world_id': world_id,
                    'added_entities': {}
                }
                
            # Step 5: Get existing world entities
            world_entities = self.app_context.get_world_entities(world_id)
            
            # Step 6: Compare and find new entities
            new_entities = self._find_new_entities(entities, world_entities)
            if not new_entities:
                return {
                    'success': True,
                    'message': "All entities already exist in the world",
                    'case_id': case_id,
                    'world_id': world_id,
                    'added_entities': {}
                }
                
            # Step 7: Add new entities to the world's ontology
            added_entities = self._add_entities_to_world(new_entities, world_id, ontology_id)
            
            # Step 8: Create associations between case and entities
            self._associate_case_with_entities(case_id, added_entities, world_id)
            
            return {
                'success': True,
                'message': f"Successfully integrated {sum(len(entities) for entities in added_entities.values())} new entities",
                'case_id': case_id,
                'world_id': world_id,
                'added_entities': added_entities
            }
            
        except Exception as e:
            logger.error(f"Error integrating case entities: {str(e)}")
            import traceback
            traceback.print_exc()
            return {
                'success': False,
                'message': f"Error: {str(e)}"
            }
    
    def _extract_entities_from_triples(self, triples):
        """
        Extract entities from triples.
        
        Args:
            triples: List of entity triples
            
        Returns:
            dict: Dictionary of entities by category
        """
        entities = {
            'roles': [],
            'conditions': [],
            'resources': [],
            'actions': [],
            'events': [],
            'capabilities': []
        }
        
        # Map predicate patterns to entity types
        predicate_to_entity_type = {
            'hasRole': 'roles',
            'involvesCondition': 'conditions',
            'involvesResource': 'resources',
            'involvesAction': 'actions',
            'involvesEvent': 'events',
            'hasCapability': 'capabilities'
        }
        
        for triple in triples:
            # Skip literal objects - we only want entity references
            if triple.get('is_literal', True):
                continue
                
            # Extract the predicate name from the URI
            predicate = triple.get('predicate', '')
            predicate_name = predicate.split('/')[-1]
            
            # Find which entity type this belongs to
            entity_type = None
            for key, value in predicate_to_entity_type.items():
                if key in predicate_name:
                    entity_type = value
                    break
                    
            if not entity_type:
                continue
                
            # Extract the entity name from the object URI
            object_uri = triple.get('object_uri', '')
            entity_name = object_uri.split('/')[-1]
            
            # Get metadata if available
            metadata = triple.get('triple_metadata', {})
            description = metadata.get('role_description', '')
            description = description or metadata.get('condition_description', '')
            description = description or metadata.get('resource_description', '')
            description = description or metadata.get('action_description', '')
            description = description or metadata.get('event_description', '')
            description = description or metadata.get('capability_description', '')
            description = description or f"Entity extracted from case"
            
            # Create entity object
            entity = {
                'label': entity_name,
                'name': entity_name,
                'description': description,
                'uri': object_uri
            }
            
            # Add to the appropriate category
            if entity not in entities[entity_type]:
                entities[entity_type].append(entity)
        
        return entities
    
    def _find_new_entities(self, extracted_entities, world_entities):
        """
        Find entities that don't exist in the world.
        
        Args:
            extracted_entities: Dictionary of entities extracted from case
            world_entities: Dictionary of entities that exist in the world
            
        Returns:
            dict: Dictionary of new entities by category
        """
        new_entities = {
            'roles': [],
            'conditions': [],
            'resources': [],
            'actions': [],
            'events': [],
            'capabilities': []
        }
        
        # For each entity type
        for entity_type in new_entities.keys():
            # Get existing entities of this type
            existing = world_entities.get('entities', {}).get(entity_type, [])
            existing_labels = [e.get('label', '').lower() for e in existing]
            
            # Check each extracted entity
            for entity in extracted_entities.get(entity_type, []):
                entity_label = entity.get('label', '').lower()
                
                # If it doesn't exist, add it to new entities
                if entity_label and entity_label not in existing_labels:
                    new_entities[entity_type].append(entity)
        
        return new_entities
    
    def _add_entities_to_world(self, new_entities, world_id, ontology_id):
        """
        Add new entities to the world's ontology.
        
        Args:
            new_entities: Dictionary of new entities by category
            world_id: ID of the world
            ontology_id: ID of the ontology
            
        Returns:
            dict: Dictionary of added entities
        """
        added_entities = {
            'roles': [],
            'conditions': [],
            'resources': [],
            'actions': [],
            'events': [],
            'capabilities': []
        }
        
        # For each entity type
        for entity_type, entities in new_entities.items():
            # Skip if no entities of this type
            if not entities:
                continue
                
            logger.info(f"Adding {len(entities)} new {entity_type} to world {world_id}")
            
            # Add each entity
            for entity in entities:
                # Prepare entity data
                entity_data = {
                    'label': entity.get('label', ''),
                    'name': entity.get('name', entity.get('label', '')),
                    'description': entity.get('description', ''),
                    'type': entity_type[:-1],  # Remove 's' from the end (roles -> role)
                    'world_id': world_id,
                    'ontology_id': ontology_id,
                    'created_at': datetime.now().isoformat(),
                    'updated_at': datetime.now().isoformat()
                }
                
                # Add to ontology
                result = add_entity_to_ontology(ontology_id, entity_data)
                
                if result.get('success'):
                    entity_data['id'] = result.get('entity_id')
                    added_entities[entity_type].append(entity_data)
                    logger.info(f"Added {entity_type[:-1]} '{entity.get('label')}' to world {world_id}")
                else:
                    logger.warning(f"Failed to add {entity_type[:-1]} '{entity.get('label')}': {result.get('message')}")
        
        return added_entities
    
    def _associate_case_with_entities(self, case_id, added_entities, world_id):
        """
        Create associations between a case and entities.
        
        Args:
            case_id: ID of the case
            added_entities: Dictionary of added entities
            world_id: ID of the world
            
        Returns:
            bool: Whether the operation was successful
        """
        # Create association triples
        association_triples = []
        
        # Map entity types to predicates
        entity_type_to_predicate = {
            'roles': 'hasWorldRole',
            'conditions': 'hasWorldCondition',
            'resources': 'hasWorldResource',
            'actions': 'hasWorldAction',
            'events': 'hasWorldEvent',
            'capabilities': 'hasWorldCapability'
        }
        
        # For each entity type
        for entity_type, entities in added_entities.items():
            # Skip if no entities of this type
            if not entities:
                continue
                
            # Create triples for each entity
            predicate = entity_type_to_predicate.get(entity_type)
            
            for entity in entities:
                triple = {
                    'subject': f"Case {case_id}",
                    'predicate': f"http://proethica.org/ontology/{predicate}",
                    'object_uri': f"http://proethica.org/ontology/world/{world_id}/{entity_type}/{entity.get('id')}",
                    'is_literal': False,
                    'graph': f"http://proethica.org/world-integration",
                    'triple_metadata': {
                        'world_id': world_id,
                        'entity_id': entity.get('id'),
                        'entity_type': entity_type,
                        'entity_label': entity.get('label')
                    }
                }
                
                association_triples.append(triple)
        
        # Store the triples if any were created
        if association_triples:
            logger.info(f"Creating {len(association_triples)} association triples for case {case_id}")
            self.app_context.store_entity_triples(case_id, association_triples, replace=False)
            return True
            
        return False


def integrate_case_with_world(case_id, world_id=None, triples=None):
    """
    Integrate entities from a case into its associated world.
    
    Args:
        case_id: ID of the case
        world_id: Optional ID of the world to integrate with
        triples: Optional list of entity triples
        
    Returns:
        dict: Result of the integration process
    """
    integrator = WorldEntityIntegrator()
    return integrator.integrate_case_entities(case_id, world_id, triples)


if __name__ == "__main__":
    """Run as a standalone script for testing."""
    import argparse
    
    parser = argparse.ArgumentParser(description='Integrate case entities with a world')
    parser.add_argument('case_id', type=int, help='ID of the case')
    parser.add_argument('--world_id', type=int, help='ID of the world (optional)')
    
    args = parser.parse_args()
    
    result = integrate_case_with_world(args.case_id, args.world_id)
    
    if result['success']:
        added_count = sum(len(entities) for entities in result['added_entities'].values())
        logger.info(f"Success: {result['message']}")
        logger.info(f"Added {added_count} new entities to world {result['world_id']}")
        
        # Print summary of added entities
        for entity_type, entities in result['added_entities'].items():
            if entities:
                entity_labels = [e.get('label') for e in entities]
                logger.info(f"  {entity_type}: {', '.join(entity_labels)}")
    else:
        logger.error(f"Error: {result['message']}")
