{% extends "base.html" %}

{% block title %}Ontology Agent Window{% endblock %}

{% block styles %}
<style>
    .agent-window {
        height: 70vh; /* Use viewport height to make it taller */
        border: 1px solid #ccc;
        border-radius: 8px;
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
        position: relative;
    }

    .conversation {
        flex-grow: 1;
        overflow-y: auto;
        padding: 15px;
        background-color: #f8f9fa;
    }

    .message {
        margin-bottom: 15px;
        padding: 10px;
        border-radius: 8px;
        max-width: 80%;
        display: block;
    }

    .user-message {
        background-color: #007bff;
        color: white;
        margin-left: auto;
        text-align: right;
    }

    .agent-message {
        background-color: #e9ecef;
        color: #212529;
        margin-right: auto;
        text-align: left;
    }

    .input-area {
        padding: 10px;
        border-top: 1px solid #ccc;
        display: flex;
        flex-direction: column;
        background-color: white;
        position: sticky;
        bottom: 0;
        width: 100%;
    }

    .prompt-options {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 10px;
    }

    .prompt-option {
        background-color: #e9ecef;
        border: none;
        border-radius: 12px;
        padding: 4px 10px;
        font-size: 0.9rem;
        margin: 2px;
        cursor: pointer;
    }

    .prompt-option:hover {
        background-color: #dee2e6;
    }

    .input-disabled {
        background-color: #e9ecef;
        cursor: not-allowed;
    }

    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0, 123, 255, 0.3);
        border-radius: 50%;
        border-top-color: #007bff;
        animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    /* Styles for ontology visualization panel */
    .ontology-panel {
        height: 70vh;
        border: 1px solid #ccc;
        border-radius: 8px;
        overflow-y: auto;
        background-color: #f8f9fa;
        padding: 15px;
        transition: all 0.3s ease;
        width: 100%;
        display: flex;
        flex-direction: column;
    }

    .ontology-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e5e5e5;
    }

    .ontology-content {
        flex-grow: 1;
        overflow-y: auto;
    }

    /* Entity visualization */
    .entity-list {
        list-style-type: none;
        padding: 0;
    }

    .entity-item {
        padding: 8px 12px;
        margin-bottom: 8px;
        border-radius: 4px;
        background-color: #e9ecef;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .entity-item:hover {
        background-color: #dee2e6;
    }
    
    .entity-item.selected {
        background-color: #b8daff;
        border-left: 3px solid #007bff;
    }

    .entity-details {
        margin-top: 20px;
        padding: 15px;
        background-color: #fff;
        border-radius: 8px;
        border: 1px solid #dee2e6;
    }

    .entity-property {
        margin-bottom: 8px;
        border-bottom: 1px solid #f1f1f1;
        padding-bottom: 8px;
    }

    .entity-property-label {
        font-weight: bold;
        color: #495057;
    }

    .entity-property-value {
        color: #212529;
    }

    .entity-details-inline {
        list-style-type: none;
        margin: -4px 0 12px 0;
        padding: 0;
    }
    
    .entity-details-inline .entity-details {
        margin-top: 0;
        margin-left: 20px;
        border-top: none;
        border-left: 3px solid #007bff;
        background-color: #f0f7ff;
    }

    .ontology-filter {
        margin-bottom: 15px;
    }

    /* Guidelines panel */
    .guidelines-panel {
        height: 70vh;
        border: 1px solid #ccc;
        border-radius: 8px;
        overflow-y: auto;
        background-color: #f8f9fa;
        padding: 15px;
        transition: all 0.3s ease;
        width: 100%;
        display: flex;
        flex-direction: column;
    }

    .guidelines-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e5e5e5;
    }

    .guidelines-content {
        flex-grow: 1;
        overflow-y: auto;
    }

    /* Collapsed panels */
    .panel-collapsed {
        width: 60px;
        overflow: hidden;
        padding: 10px 5px;
    }

    .panel-collapsed .header h5,
    .panel-collapsed .content {
        display: none;
    }

    .panel-collapsed .header {
        padding: 0;
        margin: 0;
        border: none;
        justify-content: center;
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <div id="ontology-agent-app">
        <!-- Selection dropdowns row -->
        <div class="row mb-3">
            <div class="col-md-4">
                <label for="world-select" class="form-label">Select World:</label>
                <select id="world-select" class="form-select" v-model="selectedWorldId" @change="worldChanged">
                    <option value="">-- Select a World --</option>
                    {% for world in worlds %}
                    <option value="{{ world.id }}">{{ world.name }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="col-md-4" v-if="!selectedWorldId">
                <label for="ontology-select" class="form-label">Select Ontology:</label>
                <select id="ontology-select" class="form-select" v-model="selectedOntologyId" @change="ontologyChanged">
                    <option value="">-- Select an Ontology --</option>
                    {% for ontology in ontologies %}
                    <option value="{{ ontology.id }}">{{ ontology.name }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="col-md-4" v-else>
                <label class="form-label">Selected World's Ontology:</label>
                <div class="form-control" disabled>{% raw %}{{ worldOntologyName || 'Default ontology for selected world' }}{% endraw %}</div>
            </div>
            <div class="col-md-4">
                <label for="service-select" class="form-label">LLM Service:</label>
                <select id="service-select" class="form-select" v-model="selectedService" @change="serviceChanged">
                    <option value="claude">Claude (Anthropic)</option>
                    <option value="langchain">LangChain (Mock)</option>
                </select>
            </div>
        </div>

        <!-- Three-column layout -->
        <div class="row">
            <!-- Ontology panel - left column -->
            <div :class="{'col-md-3': !isOntologyPanelCollapsed, 'col-md-1': isOntologyPanelCollapsed}">
                <div :class="{'ontology-panel': true, 'panel-collapsed': isOntologyPanelCollapsed}">
                    <div class="ontology-header header">
                        <h5>Ontology Entities</h5>
                        <button class="btn btn-sm btn-outline-secondary toggle-panel" @click="toggleOntologyPanel">
                            <i :class="isOntologyPanelCollapsed ? 'bi bi-chevron-right' : 'bi bi-chevron-left'"></i>
                        </button>
                    </div>
                    <div class="ontology-content content">
                        <div class="ontology-filter">
                            <select class="form-select form-select-sm" v-model="entityTypeFilter">
                                <option value="all">All Entity Types</option>
                                <option value="roles">Roles</option>
                                <option value="capabilities">Capabilities</option>
                                <option value="conditions">Conditions</option>
                                <option value="resources">Resources</option>
                                <option value="events">Events</option>
                                <option value="actions">Actions</option>
                            </select>
                        </div>
                        
                        <div v-if="isLoadingEntities" class="text-center py-5">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading entities...</span>
                            </div>
                            <p class="mt-2">Loading entities...</p>
                        </div>
                        
                        <div v-else-if="entities.length === 0" class="text-center py-5 text-muted">
                            <i class="bi bi-exclamation-circle" style="font-size: 2rem;"></i>
                            <p class="mt-2">No entities found. Select a world or ontology to view entities.</p>
                        </div>
                        
                        <div v-else>
                            <div class="entity-list-container" style="max-height: 100%; overflow-y: auto">
                                <ul class="entity-list">
                                    <template v-for="entity in filteredEntities">
                                        <li :key="entity.uri + '-item'" class="entity-item"
                                            @click="selectEntity(entity)" 
                                            :class="{ 'selected': selectedEntity && selectedEntity.uri === entity.uri }">
                                            {% raw %}{{ entity.label }}{% endraw %}
                                        </li>
                                        <!-- Inline entity details that expand under the selected item -->
                                        <li :key="entity.uri + '-details'" v-if="selectedEntity && selectedEntity.uri === entity.uri" 
                                            class="entity-details-inline">
                                            <div class="entity-details p-2">
                                                <div class="entity-property" v-if="selectedEntity.description">
                                                    <div class="entity-property-label">Description:</div>
                                                    <div class="entity-property-value">{% raw %}{{ selectedEntity.description }}{% endraw %}</div>
                                                </div>
                                                <div class="entity-property">
                                                    <div class="entity-property-label">URI:</div>
                                                    <div class="entity-property-value text-truncate">{% raw %}{{ selectedEntity.uri }}{% endraw %}</div>
                                                </div>
                                                <div class="mt-2">
                                                    <button class="btn btn-sm btn-primary" @click="askAboutEntity(selectedEntity)">
                                                        Ask About This Entity
                                                    </button>
                                                    <button class="btn btn-sm btn-outline-secondary ms-1" @click="selectedEntity = null">
                                                        Close
                                                    </button>
                                                </div>
                                            </div>
                                        </li>
                                    </template>
                                </ul>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Chat window - middle column -->
            <div :class="{
                'col-md-6': !isOntologyPanelCollapsed && !isGuidelinesPanelCollapsed,
                'col-md-8': (isOntologyPanelCollapsed && !isGuidelinesPanelCollapsed) || (!isOntologyPanelCollapsed && isGuidelinesPanelCollapsed),
                'col-md-10': isOntologyPanelCollapsed && isGuidelinesPanelCollapsed
            }">
                <div class="agent-window">
                    <div class="conversation" ref="conversation">
                        <div v-for="(message, index) in messages" :key="index" class="message"
                            :class="message.role === 'user' ? 'user-message' : 'agent-message'">
                            {% raw %}{{ message.content }}{% endraw %}
                        </div>
                        <div v-if="isProcessing" class="message agent-message">
                            <div class="loading"></div> Thinking...
                        </div>
                    </div>

                    <div class="input-area">
                        <!-- Add suggestion button when ontology source is selected but no suggestions are shown -->
                        <div v-if="hasOntologySource && promptOptions.length === 0" class="w-100 mb-2">
                            <button
                                class="btn btn-outline-secondary w-100 d-flex align-items-center justify-content-center"
                                @click="generateSuggestions"
                                :disabled="isFetchingSuggestions">
                                <i class="bi bi-lightbulb me-2" style="font-size: 1.1rem;"></i>
                                <span>Generate Suggestions</span>
                                <span v-if="isFetchingSuggestions" class="spinner-border spinner-border-sm ms-2" role="status" aria-hidden="true"></span>
                            </button>
                        </div>

                        <!-- Show prompt options when ontology source is selected and options are available -->
                        <div v-if="hasOntologySource && promptOptions.length > 0" class="prompt-options w-100">
                            <button v-for="option in promptOptions" :key="option.id" class="prompt-option"
                                @click="selectPromptOption(option)">
                                {% raw %}{{ option.text }}{% endraw %}
                            </button>
                        </div>

                        <!-- Input box is always shown but with different placeholder based on ontology selection -->
                        <div class="input-group">
                            <input type="text" class="form-control" v-model="userInput"
                                :disabled="!inputEnabled || isProcessing"
                                :class="{ 'input-disabled': !inputEnabled || isProcessing }"
                                :placeholder="hasOntologySource ? 'Ask questions about this ontology...' : 'Select a world or ontology first...'"
                                @keyup.enter="sendMessage">
                            <button class="btn btn-primary" @click="sendMessage" :disabled="!inputEnabled || isProcessing">
                                Send
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Agent window control buttons -->
                <div class="d-flex mt-2 gap-2">
                    <button class="btn btn-secondary" @click="resetConversation">
                        <i class="bi bi-arrow-repeat"></i> Reset Conversation
                    </button>
                    <a href="/agent/" class="btn btn-outline-secondary">
                        <i class="bi bi-back"></i> Back to Regular Agent
                    </a>
                </div>
            </div>

            <!-- Guidelines section - right column -->
            <div :class="{'col-md-3': !isGuidelinesPanelCollapsed, 'col-md-1': isGuidelinesPanelCollapsed}">
                <div :class="{'guidelines-panel': true, 'panel-collapsed': isGuidelinesPanelCollapsed}">
                    <div class="guidelines-header header">
                        <h5>Ontology Guidelines</h5>
                        <button class="btn btn-sm btn-outline-secondary toggle-panel" @click="toggleGuidelinesPanel">
                            <i :class="isGuidelinesPanelCollapsed ? 'bi bi-chevron-left' : 'bi bi-chevron-right'"></i>
                        </button>
                    </div>
                    <div class="guidelines-content content">
                        <div v-if="isLoadingGuidelines" class="text-center py-5">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Loading guidelines...</span>
                            </div>
                            <p class="mt-2">Loading guidelines...</p>
                        </div>
                        
                        <div v-else-if="!formattedGuidelines" class="text-center py-5 text-muted">
                            <i class="bi bi-info-circle" style="font-size: 2rem;"></i>
                            <p class="mt-2">No guidelines available for this ontology.</p>
                        </div>
                        
                        <div v-else v-html="formattedGuidelines" class="guidelines-content"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
{% endblock %}

{% block scripts %}
<!-- Include necessary libraries -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
<script>
    new Vue({
        el: '#ontology-agent-app',
        data: {
            messages: [],
            userInput: '',
            inputEnabled: true,
            promptOptions: [],
            isProcessing: false,
            isFetchingSuggestions: false,
            
            // Selected IDs
            selectedWorldId: '{{ selected_world.id if selected_world else "" }}',
            selectedOntologyId: '{{ selected_ontology.id if selected_ontology else "" }}',
            selectedService: 'claude', // Default to Claude
            worldOntologyName: '', // Name of the ontology associated with the selected world
            
            // Ontology panel data
            entities: [],
            filteredEntities: [],
            selectedEntity: null,
            entityTypeFilter: 'all',
            isLoadingEntities: false,
            
            // Guidelines data
            guidelines: '',
            formattedGuidelines: '',
            isLoadingGuidelines: false,
            
            // Panel states
            isOntologyPanelCollapsed: false,
            isGuidelinesPanelCollapsed: false
        },
        computed: {
            hasOntologySource() {
                return this.selectedWorldId || this.selectedOntologyId;
            }
        },
        watch: {
            entityTypeFilter: {
                handler: function(newVal) {
                    this.filterEntities();
                }
            }
        },
        mounted() {
            // Initialize conversation from session
            this.initializeConversation();
            
            // Load entities and guidelines if world or ontology is selected
            if (this.selectedWorldId || this.selectedOntologyId) {
                this.loadEntities();
                this.loadGuidelines();
            }

            // Check for saved collapsed states
            const savedOntologyPanelState = localStorage.getItem('ontologyPanelCollapsed');
            if (savedOntologyPanelState) {
                this.isOntologyPanelCollapsed = savedOntologyPanelState === 'true';
            }

            const savedGuidelinesPanelState = localStorage.getItem('guidelinesPanelCollapsed');
            if (savedGuidelinesPanelState) {
                this.isGuidelinesPanelCollapsed = savedGuidelinesPanelState === 'true';
            }
        },
        methods: {
            // Toggle the ontology panel collapse state
            toggleOntologyPanel() {
                this.isOntologyPanelCollapsed = !this.isOntologyPanelCollapsed;
                localStorage.setItem('ontologyPanelCollapsed', this.isOntologyPanelCollapsed);
            },

            // Toggle the guidelines panel collapse state
            toggleGuidelinesPanel() {
                this.isGuidelinesPanelCollapsed = !this.isGuidelinesPanelCollapsed;
                localStorage.setItem('guidelinesPanelCollapsed', this.isGuidelinesPanelCollapsed);
            },

            // Handle world change
            worldChanged() {
                // Reset ontology selection if world changes
                this.selectedOntologyId = '';
                this.worldOntologyName = '';
                
                // Reset conversation if world changes
                if (this.messages.length > 1) {
                    if (confirm('Changing worlds will reset your current conversation. Continue?')) {
                        this.resetConversation();
                    } else {
                        // Restore the previous selection
                        this.$nextTick(() => {
                            const select = document.getElementById('world-select');
                            if (select) {
                                select.value = this.selectedWorldId;
                            }
                        });
                        return;
                    }
                }

                // Get the world's ontology name if a world is selected
                if (this.selectedWorldId) {
                    // Fetch the world details to get the ontology name
                    axios.get(`/agent/ontology/api/world-ontology?world_id=${this.selectedWorldId}`)
                        .then(response => {
                            if (response.data.status === 'success' && response.data.ontology) {
                                this.worldOntologyName = response.data.ontology.name;
                            } else {
                                this.worldOntologyName = 'Default ontology for selected world';
                            }
                        })
                        .catch(error => {
                            console.error('Error fetching world ontology:', error);
                            this.worldOntologyName = 'Default ontology for selected world';
                        });
                }

                // Load entities and guidelines for the selected world
                this.loadEntities();
                this.loadGuidelines();
            },

            // Handle ontology change
            ontologyChanged() {
                // Reset world selection if ontology changes
                this.selectedWorldId = '';
                
                // Reset conversation if ontology changes
                if (this.messages.length > 1) {
                    if (confirm('Changing ontologies will reset your current conversation. Continue?')) {
                        this.resetConversation();
                    } else {
                        // Restore the previous selection
                        this.$nextTick(() => {
                            const select = document.getElementById('ontology-select');
                            if (select) {
                                select.value = this.selectedOntologyId;
                            }
                        });
                        return;
                    }
                }

                // Load entities and guidelines for the selected ontology
                this.loadEntities();
                this.loadGuidelines();
            },

            // Handle service change
            serviceChanged() {
                // Just for consistency with the regular agent
                console.log('Service changed to:', this.selectedService);
            },

            // Load entities from the selected ontology source
            loadEntities() {
                if (!this.selectedWorldId && !this.selectedOntologyId) {
                    this.entities = [];
                    this.filteredEntities = [];
                    this.selectedEntity = null;
                    return;
                }

                this.isLoadingEntities = true;
                
                // Build URL with parameters
                let url = '/agent/ontology/api/entities?';
                if (this.selectedWorldId) {
                    url += `world_id=${this.selectedWorldId}`;
                } else if (this.selectedOntologyId) {
                    url += `ontology_id=${this.selectedOntologyId}`;
                }
                
                console.log(`Loading entities from: ${url}`);
                
                axios.get(url)
                    .then(response => {
                        console.log("Response from entities API:", response.data);
                        
                        if (response.data.status === 'success') {
                            // Normalize the entities format
                            let allEntities = [];
                            
                            // Ensure we have entities object to work with
                            const entitiesData = response.data.entities || {};
                            
                            // Process different entity types
                            const entityTypes = ['roles', 'capabilities', 'conditions', 'resources', 'events', 'actions'];
                            entityTypes.forEach(type => {
                                // Check if the entity type exists in the response
                                if (entitiesData[type] && Array.isArray(entitiesData[type])) {
                                    entitiesData[type].forEach(entity => {
                                        // Ensure entity has all expected properties
                                        const normalizedEntity = {
                                            uri: entity.uri || `unknown:/${type}/${Math.random().toString(36).substring(7)}`,
                                            label: entity.label || "Unnamed entity",
                                            description: entity.description || "",
                                            entityType: type.slice(0, -1), // remove trailing 's'
                                            ...entity // preserve any additional fields
                                        };
                                        
                                        allEntities.push(normalizedEntity);
                                    });
                                }
                            });
                            
                            console.log("Normalized entities:", allEntities);
                            this.entities = allEntities;
                            this.filterEntities();
                        } else {
                            console.error('Error loading entities:', response.data.message);
                            this.entities = [];
                            this.filteredEntities = [];
                        }
                    })
                    .catch(error => {
                        console.error('Error loading entities:', error);
                        this.entities = [];
                        this.filteredEntities = [];
                    })
                    .finally(() => {
                        this.isLoadingEntities = false;
                    });
            },

            // Filter entities based on selected type
            filterEntities() {
                console.log("Filtering entities, current filter:", this.entityTypeFilter);
                console.log("Available entities:", this.entities);
                
                if (this.entityTypeFilter === 'all') {
                    this.filteredEntities = this.entities;
                } else {
                    // The entity type might be stored differently in different scenarios
                    // Try multiple approaches to match the entity type
                    this.filteredEntities = this.entities.filter(entity => {
                        // Check for entityType property explicitly added
                        if (entity.entityType && entity.entityType === this.entityTypeFilter.slice(0, -1)) {
                            return true;
                        }
                        
                        // Check by URI pattern (often contains the entity type)
                        if (entity.uri && entity.uri.toLowerCase().includes(`/${this.entityTypeFilter.toLowerCase()}/`)) {
                            return true;
                        }
                        
                        // Check explicit type field if available
                        if (entity.type && entity.type.toLowerCase() === this.entityTypeFilter.toLowerCase().slice(0, -1)) {
                            return true;
                        }
                        
                        return false;
                    });
                }
                
                console.log("Filtered entities:", this.filteredEntities);
                
                // Sort alphabetically by label
                this.filteredEntities.sort((a, b) => a.label.localeCompare(b.label));
            },

            // Select an entity to view details
            selectEntity(entity) {
                this.selectedEntity = entity;
                
                // Get more details about the entity if needed using the API
                if (this.selectedWorldId || this.selectedOntologyId) {
                    // Build URL with parameters
                    let url = `/agent/ontology/api/entities/details?uri=${encodeURIComponent(entity.uri)}`;
                    if (this.selectedWorldId) {
                        url += `&world_id=${this.selectedWorldId}`;
                    } else if (this.selectedOntologyId) {
                        url += `&ontology_id=${this.selectedOntologyId}`;
                    }
                    
                    // You would need to implement the details API endpoint
                    // For now, we'll just use the basic entity information
                }
            },

            // Ask a question about a specific entity
            askAboutEntity(entity) {
                const question = `Tell me about the ${entity.label} ${entity.entityType} in this ontology.`;
                this.userInput = question;
                this.sendMessage();
            },

            // Load guidelines for selected ontology
            loadGuidelines() {
                if (!this.selectedWorldId && !this.selectedOntologyId) {
                    this.guidelines = '';
                    this.formattedGuidelines = '';
                    return;
                }

                this.isLoadingGuidelines = true;
                
                // Build URL with parameters
                let url = '/agent/api/guidelines?';
                if (this.selectedWorldId) {
                    url += `world_id=${this.selectedWorldId}`;
                } else if (this.selectedOntologyId) {
                    // The guidelines endpoint should be updated to handle ontology_id
                    // For now, we'll just try world_id
                    url += `world_id=${this.selectedOntologyId}`;
                }
                
                axios.get(url)
                    .then(response => {
                        if (response.data.status === 'success') {
                            this.guidelines = response.data.guidelines || '';
                            // Format the guidelines with markdown
                            this.formattedGuidelines = this.guidelines ? marked.parse(this.guidelines) : '';
                        } else {
                            console.error('Error getting guidelines:', response.data.message);
                            this.guidelines = '';
                            this.formattedGuidelines = '';
                        }
                    })
                    .catch(error => {
                        console.error('Error getting guidelines:', error);
                        this.guidelines = '';
                        this.formattedGuidelines = '';
                    })
                    .finally(() => {
                        this.isLoadingGuidelines = false;
                    });
            },

            // Scroll to bottom of conversation
            scrollToBottom() {
                this.$nextTick(() => {
                    if (this.$refs.conversation) {
                        this.$refs.conversation.scrollTop = this.$refs.conversation.scrollHeight;
                    }
                });
            },

            initializeConversation() {
                // Initialize with a welcome message
                this.messages = [
                    { 
                        role: 'assistant', 
                        content: 'Hello! I am your ontology assistant. Choose a world or ontology to explore and ask questions about the ontology structure, entities, and relationships.' 
                    }
                ];
            },

            sendMessage() {
                if (!this.inputEnabled || !this.userInput.trim() || this.isProcessing) return;
                
                // Check if world or ontology is selected
                if (!this.selectedWorldId && !this.selectedOntologyId) {
                    alert('Please select a world or ontology first.');
                    return;
                }

                // Add user message to conversation
                this.messages.push({ role: 'user', content: this.userInput });

                // Clear input and disable it while processing
                const userMessage = this.userInput;
                this.userInput = '';
                this.inputEnabled = true;
                this.isProcessing = true;
                this.promptOptions = [];

                // Scroll to bottom
                this.scrollToBottom();

                // Send message to API
                axios.post('/agent/ontology/api/message', {
                    message: userMessage,
                    world_id: this.selectedWorldId || null,
                    ontology_id: this.selectedOntologyId || null,
                    service: this.selectedService
                })
                    .then(response => {
                        if (response.data.status === 'success') {
                            // Add assistant response to conversation
                            this.messages.push({
                                role: response.data.message.role,
                                content: response.data.message.content
                            });

                            // Get new prompt options
                            this.generateSuggestions();
                        } else {
                            // Add error message
                            this.messages.push({
                                role: 'assistant',
                                content: 'Sorry, there was an error processing your request.'
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error sending message:', error);
                        // Add error message
                        this.messages.push({
                            role: 'assistant',
                            content: 'Sorry, there was an error processing your request.'
                        });
                    })
                    .finally(() => {
                        // Re-enable input
                        this.isProcessing = false;
                        this.scrollToBottom();
                    });
            },

            selectPromptOption(option) {
                // Add selected option to conversation as user message
                this.messages.push({ role: 'user', content: option.text });

                // Clear prompt options and disable input while processing
                this.promptOptions = [];
                this.inputEnabled = true;
                this.isProcessing = true;

                // Scroll to bottom
                this.scrollToBottom();

                // Send to API
                axios.post('/agent/ontology/api/message', {
                    message: option.text,
                    world_id: this.selectedWorldId || null,
                    ontology_id: this.selectedOntologyId || null,
                    service: this.selectedService
                })
                    .then(response => {
                        if (response.data.status === 'success') {
                            // Add assistant response to conversation
                            this.messages.push({
                                role: response.data.message.role,
                                content: response.data.message.content
                            });

                            // Get new prompt options
                            this.generateSuggestions();
                        } else {
                            // Add error message
                            this.messages.push({
                                role: 'assistant',
                                content: 'Sorry, there was an error processing your request.'
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error sending message:', error);
                        // Add error message
                        this.messages.push({
                            role: 'assistant',
                            content: 'Sorry, there was an error processing your request.'
                        });
                    })
                    .finally(() => {
                        // Re-enable input
                        this.isProcessing = false;
                        this.scrollToBottom();
                    });
            },

            resetConversation() {
                // Initialize with welcome message
                this.initializeConversation();
                this.promptOptions = [];

                // Reset conversation state on server
                axios.post('/agent/ontology/api/reset', {
                    world_id: this.selectedWorldId || null,
                    ontology_id: this.selectedOntologyId || null
                })
                    .catch(error => {
                        console.error('Error resetting conversation:', error);
                    });
            },

            generateSuggestions() {
                if (!this.hasOntologySource || this.isFetchingSuggestions) return;

                this.isFetchingSuggestions = true;

                axios.post('/agent/ontology/api/suggestions', {
                    world_id: this.selectedWorldId || null,
                    ontology_id: this.selectedOntologyId || null
                })
                    .then(response => {
                        if (response.data.status === 'success') {
                            this.promptOptions = response.data.suggestions || [];
                        } else {
                            console.error('Error generating suggestions:', response.data.message);
                            this.promptOptions = [];
                        }
                    })
                    .catch(error => {
                        console.error('Error generating suggestions:', error);
                        this.promptOptions = [];
                    })
                    .finally(() => {
                        this.isFetchingSuggestions = false;
                    });
            }
        }
    });
</script>
{% endblock %}
