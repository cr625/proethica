{% extends "base.html" %}

{% block title %}Agent Window Prototype{% endblock %}

{% block styles %}
<style>
    .agent-window {
        height: 70vh;
        /* Use viewport height to make it taller */
        border: 1px solid #ccc;
        border-radius: 8px;
        margin-bottom: 20px;
        display: flex;
        flex-direction: column;
        position: relative;
    }

    .conversation {
        flex-grow: 1;
        overflow-y: auto;
        padding: 15px;
        background-color: #f8f9fa;
    }

    .message {
        margin-bottom: 15px;
        padding: 10px;
        border-radius: 8px;
        max-width: 80%;
        display: block;
    }

    .user-message {
        background-color: #007bff;
        color: white;
        margin-left: auto;
        text-align: right;
    }

    .agent-message {
        background-color: #e9ecef;
        color: #212529;
        margin-right: auto;
        text-align: left;
    }

    .input-area {
        padding: 10px;
        border-top: 1px solid #ccc;
        display: flex;
        flex-direction: column;
        background-color: white;
        position: sticky;
        bottom: 0;
        width: 100%;
    }

    .prompt-options {
        display: flex;
        flex-wrap: wrap;
        gap: 10px;
        margin-bottom: 10px;
    }

    .prompt-option {
        background-color: #e9ecef;
        border: none;
        border-radius: 12px;
        padding: 4px 10px;
        font-size: 0.9rem;
        margin: 2px;
        cursor: pointer;
    }

    .prompt-option:hover {
        background-color: #dee2e6;
    }

    .input-disabled {
        background-color: #e9ecef;
        cursor: not-allowed;
    }

    .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(0, 123, 255, 0.3);
        border-radius: 50%;
        border-top-color: #007bff;
        animation: spin 1s ease-in-out infinite;
    }

    @keyframes spin {
        to {
            transform: rotate(360deg);
        }
    }

    /* Styles for history panel */
    .history-panel {
        height: 70vh;
        border: 1px solid #ccc;
        border-radius: 8px;
        overflow-y: auto;
        background-color: #f8f9fa;
        padding: 0;
        transition: all 0.3s ease;
        width: 100%;
    }

    /* Collapsed history panel */
    .history-panel-collapsed {
        width: 60px;
        overflow: hidden;
    }

    .history-panel-collapsed .history-header h5,
    .history-panel-collapsed .conversation-list,
    .history-panel-collapsed .no-conversations,
    .history-panel-collapsed .spinner-border,
    .history-panel-collapsed .pagination-controls,
    .history-panel-collapsed .refresh-button {
        display: none;
    }

    .history-panel-collapsed .history-header {
        padding: 10px 5px;
        justify-content: center;
    }

    /* Styles for guidelines panel */
    .guidelines-panel {
        height: 70vh;
        border: 1px solid #ccc;
        border-radius: 8px;
        overflow-y: auto;
        background-color: #f8f9fa;
        padding: 15px;
        transition: all 0.3s ease;
        width: 100%;
        display: flex;
        flex-direction: column;
    }

    .guidelines-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 1px solid #e5e5e5;
    }

    .guidelines-content {
        flex-grow: 1;
        overflow-y: auto;
    }

    /* Collapsed guidelines panel */
    .guidelines-panel-collapsed {
        width: 60px;
        overflow: hidden;
        padding: 10px 5px;
    }

    .guidelines-panel-collapsed .guidelines-header h5,
    .guidelines-panel-collapsed .guidelines-content {
        display: none;
    }

    .guidelines-panel-collapsed .guidelines-header {
        padding: 0;
        margin: 0;
        border: none;
        justify-content: center;
    }

    /* Common styles for the history panel */
    .conversation-item {
        padding: 15px;
        border-bottom: 1px solid #e5e5e5;
        cursor: pointer;
        transition: background-color 0.2s;
    }

    .conversation-item:hover {
        background-color: #e9ecef;
    }

    .conversation-item.active {
        background-color: #e2e6ea;
        border-left: 4px solid #007bff;
    }

    .conversation-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
    }

    .conversation-title {
        font-weight: bold;
        font-size: 1.1rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .conversation-timestamp {
        color: #6c757d;
        font-size: 0.85rem;
    }

    .conversation-context {
        color: #6c757d;
        font-size: 0.9rem;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
    }

    .conversation-preview {
        display: -webkit-box;
        -webkit-line-clamp: 2;
        -webkit-box-orient: vertical;
        overflow: hidden;
        margin-top: 5px;
        color: #495057;
    }

    .no-conversations {
        padding: 40px;
        text-align: center;
        color: #6c757d;
    }

    .history-header {
        padding: 15px;
        border-bottom: 1px solid #e5e5e5;
        background-color: #f8f9fa;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .pagination-controls {
        margin-top: 15px;
        display: flex;
        justify-content: center;
    }

    /* Toggle button styling */
    .toggle-history,
    .toggle-guidelines {
        min-width: 30px;
    }
</style>
{% endblock %}

{% block content %}
<div class="container">
    <div id="agent-app">
        <!-- World selection and service selection -->
        <div class="row mb-3">
            <div class="col-md-8">
                <label for="world-select" class="form-label">Select World:</label>
                <select id="world-select" class="form-select" v-model="selectedWorldId" @change="worldChanged">
                    <option value="">-- Select a World --</option>
                    {% for world in worlds %}
                    <option value="{{ world.id }}">{{ world.name }}</option>
                    {% endfor %}
                </select>
            </div>
            <div class="col-md-4">
                <label for="service-select" class="form-label">LLM Service:</label>
                <select id="service-select" class="form-select" v-model="selectedService" @change="serviceChanged">
                    <option value="claude">Claude (Anthropic)</option>
                    <option value="langchain">LangChain (Mock)</option>
                </select>
            </div>
        </div>

        <!-- Three-column layout -->
        <div class="row">
            <!-- History panel - left column -->
            <div :class="{'col-md-3': !isHistoryCollapsed, 'col-md-1': isHistoryCollapsed}">
                {% include "history_panel.html" %}
            </div>

            <!-- Chat window - middle column -->
            <div :class="{
                'col-md-6': !isHistoryCollapsed && !isGuidelinesCollapsed,
                'col-md-8': (isHistoryCollapsed && !isGuidelinesCollapsed) || (!isHistoryCollapsed && isGuidelinesCollapsed),
                'col-md-10': isHistoryCollapsed && isGuidelinesCollapsed
            }">
                <div class="agent-window">
                    <div class="conversation" ref="conversation">
                        <div v-for="(message, index) in messages" :key="index" class="message"
                            :class="message.role === 'user' ? 'user-message' : 'agent-message'">
                            {% raw %}{{ message.content }}{% endraw %}
                        </div>
                        <div v-if="isProcessing" class="message agent-message">
                            <div class="loading"></div> Thinking...
                        </div>
                    </div>

                    <div class="input-area">
                        <!-- Add suggestion button when world is selected but no suggestions are shown -->
                        <div v-if="selectedWorldId && promptOptions.length === 0" class="w-100 mb-2">
                            <button
                                class="btn btn-outline-secondary w-100 d-flex align-items-center justify-content-center"
                                @click="generateSuggestions" :disabled="isFetchingSuggestions">
                                <i class="bi bi-lightbulb me-2" style="font-size: 1.1rem;"></i>
                                <span>Generate Suggestions</span>
                                <span v-if="isFetchingSuggestions" class="spinner-border spinner-border-sm ms-2"
                                    role="status" aria-hidden="true"></span>
                            </button>
                        </div>

                        <!-- Show prompt options when world is selected and options are available -->
                        <div v-if="selectedWorldId && promptOptions.length > 0" class="prompt-options w-100">
                            <button v-for="option in promptOptions" :key="option.id" class="prompt-option"
                                @click="selectPromptOption(option)">
                                {% raw %}{{ option.text }}{% endraw %}
                            </button>
                        </div>

                        <!-- Input box is always shown but with different placeholder based on world selection -->
                        <div class="input-group">
                            <input type="text" class="form-control" v-model="userInput"
                                :disabled="!inputEnabled || isProcessing"
                                :class="{ 'input-disabled': !inputEnabled || isProcessing }"
                                :placeholder="selectedWorldId ? 'Type your message about this world...' : 'Type any test message to Claude...'"
                                @keyup.enter="sendMessage">
                            <button class="btn btn-primary" @click="sendMessage"
                                :disabled="!inputEnabled || isProcessing">
                                Send
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Agent window control buttons -->
                <div class="d-flex mt-2 gap-2">
                    <button class="btn btn-secondary" @click="resetConversation">
                        <i class="bi bi-arrow-repeat"></i> Reset Conversation
                    </button>
                    <button class="btn btn-success" @click="saveConversation" :disabled="messages.length <= 1">
                        <i class="bi bi-save"></i> Save Conversation
                    </button>
                    <button class="btn btn-danger" v-if="currentConversationId"
                        @click="deleteConversation(currentConversationId)">
                        <i class="bi bi-trash"></i> Delete Conversation
                    </button>
                </div>
            </div>

            <!-- Guidelines section - right column -->
            <div :class="{'col-md-3': !isGuidelinesCollapsed, 'col-md-1': isGuidelinesCollapsed}">
                {% include "guidelines_panel.html" %}
            </div>
        </div>

        <!-- Save Conversation Modal -->
        <div class="modal fade" id="saveConversationModal" tabindex="-1" aria-labelledby="saveConversationModalLabel"
            aria-hidden="true">
            <div class="modal-dialog">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title" id="saveConversationModalLabel">Save Conversation</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <div class="mb-3">
                            <label for="conversation-title" class="form-label">Title</label>
                            <input type="text" class="form-control" id="conversation-title" v-model="saveTitle"
                                placeholder="Enter a title for this conversation">
                        </div>
                        <div v-if="savingConversation" class="d-flex justify-content-center my-3">
                            <div class="spinner-border text-primary" role="status">
                                <span class="visually-hidden">Saving...</span>
                            </div>
                        </div>
                        <div v-if="saveError" class="alert alert-danger" role="alert">
                            {% raw %}{{ saveError }}{% endraw %}
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-primary" @click="confirmSaveConversation"
                            :disabled="savingConversation">Save</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- Delete Confirmation Modal -->
        <div class="modal fade" id="deleteConversationModal" tabindex="-1" aria-hidden="true">
            <div class="modal-dialog modal-dialog-centered">
                <div class="modal-content">
                    <div class="modal-header">
                        <h5 class="modal-title">Confirm Delete</h5>
                        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
                    </div>
                    <div class="modal-body">
                        <p>Are you sure you want to delete this conversation? This action cannot be undone.</p>
                    </div>
                    <div class="modal-footer">
                        <button type="button" class="btn btn-secondary" data-bs-dismiss="modal">Cancel</button>
                        <button type="button" class="btn btn-danger" @click="confirmDelete">Delete</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<!-- Include Vue.js and Axios -->
<script src="https://cdn.jsdelivr.net/npm/vue@2.6.14/dist/vue.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
<script>
    new Vue({
        el: '#agent-app',
        data: {
            messages: [],
            userInput: '',
            inputEnabled: true,
            promptOptions: [],
            isProcessing: false,
            isFetchingSuggestions: false,
            selectedWorldId: '{{ selected_world.id if selected_world else "" }}',
            selectedService: 'claude', // Default to Claude
            guidelines: '',
            formattedGuidelines: '',
            welcomeMessage: '{{ welcome_message | safe }}', // Get welcome message from Flask

            // Save conversation related
            saveTitle: '',
            savingConversation: false,
            saveError: null,
            saveModal: null,  // Will hold the bootstrap modal instance
            deleteModal: null, // Will hold the delete modal instance
            conversationToDelete: null,

            // History related
            conversations: [],
            historyLoading: true,
            totalCount: 0,
            currentPage: 1,
            pageSize: 10,
            filterContextType: '',
            filterContextId: '',
            searchText: '',
            currentConversationId: null,

            // Panel state
            isHistoryCollapsed: false,
            isGuidelinesCollapsed: false,

            // MCP Integration Demo
            mcpLoading: false,
            mcpLoadingText: '',
            mcpResults: null
        },
        computed: {
            totalPages() {
                return Math.ceil(this.totalCount / this.pageSize);
            },
            paginationPages() {
                const pagesToShow = 5;
                const pages = [];

                // Calculate start and end pages to show
                let startPage = Math.max(1, this.currentPage - Math.floor(pagesToShow / 2));
                let endPage = Math.min(this.totalPages, startPage + pagesToShow - 1);

                // Adjust start page if needed
                if (endPage - startPage + 1 < pagesToShow) {
                    startPage = Math.max(1, endPage - pagesToShow + 1);
                }

                // Generate page array
                for (let i = startPage; i <= endPage; i++) {
                    pages.push(i);
                }

                return pages;
            }
        },
        mounted() {
            // Initialize modals after DOM is loaded
            this.saveModal = new bootstrap.Modal(document.getElementById('saveConversationModal'));
            this.deleteModal = new bootstrap.Modal(document.getElementById('deleteConversationModal'));

            // Initialize conversation from session
            this.initializeConversation();

            // Get guidelines if world is selected
            if (this.selectedWorldId) {
                this.getGuidelines();
            }

            // Load conversation history
            this.loadConversations(1);

            // Check for saved collapsed states
            const savedHistoryState = localStorage.getItem('historyPanelCollapsed');
            if (savedHistoryState) {
                this.isHistoryCollapsed = savedHistoryState === 'true';
            }

            const savedGuidelinesState = localStorage.getItem('guidelinesPanelCollapsed');
            if (savedGuidelinesState) {
                this.isGuidelinesCollapsed = savedGuidelinesState === 'true';
            }
        },
        methods: {
            // Toggle the history panel collapse state
            toggleHistoryPanel() {
                this.isHistoryCollapsed = !this.isHistoryCollapsed;
                localStorage.setItem('historyPanelCollapsed', this.isHistoryCollapsed);
            },

            // Toggle the guidelines panel collapse state
            toggleGuidelinesPanel() {
                this.isGuidelinesCollapsed = !this.isGuidelinesCollapsed;
                localStorage.setItem('guidelinesPanelCollapsed', this.isGuidelinesCollapsed);
            },

            // Handle world change
            worldChanged() {
                // Reset conversation if world changes
                if (this.messages.length > 1) {
                    if (confirm('Changing worlds will reset your current conversation. Continue?')) {
                        this.resetConversation();
                    } else {
                        // Restore the previous selection
                        this.$nextTick(() => {
                            const select = document.getElementById('world-select');
                            if (select) {
                                select.value = this.selectedWorldId;
                            }
                        });
                        return;
                    }
                }

                // Get guidelines for the selected world
                this.getGuidelines();

                // Save selection to session
                axios.post('/agent/api/select-world', {
                    world_id: this.selectedWorldId
                }, {
                    headers: {
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    }
                }).catch(error => {
                    console.error('Error saving world selection:', error);
                });
            },

            // Handle service change
            serviceChanged() {
                // Save selection to session
                axios.post('/agent/api/select-service', {
                    service: this.selectedService
                }).catch(error => {
                    console.error('Error saving service selection:', error);
                });
            },

            // Get guidelines for selected world
            getGuidelines() {
                if (!this.selectedWorldId) {
                    this.guidelines = '';
                    this.formattedGuidelines = '';
                    return;
                }

                axios.get(`/agent/api/guidelines?world_id=${this.selectedWorldId}`)
                    .then(response => {
                        if (response.data.status === 'success') {
                            this.guidelines = response.data.guidelines || '';
                            // Format the guidelines with markdown
                            this.formattedGuidelines = this.guidelines ? marked.parse(this.guidelines) : '';
                        } else {
                            console.error('Error getting guidelines:', response.data.message);
                            this.guidelines = '';
                            this.formattedGuidelines = '';
                        }
                    })
                    .catch(error => {
                        console.error('Error getting guidelines:', error);
                        this.guidelines = '';
                        this.formattedGuidelines = '';
                    });
            },

            // Scroll to bottom of conversation
            scrollToBottom() {
                this.$nextTick(() => {
                    if (this.$refs.conversation) {
                        this.$refs.conversation.scrollTop = this.$refs.conversation.scrollHeight;
                    }
                });
            },

            // Load conversation history
            loadConversations(page) {
                this.historyLoading = true;
                this.currentPage = page;

                // Calculate offset
                const offset = (page - 1) * this.pageSize;

                // Build query string
                let url = `/agent/history/api/conversations?limit=${this.pageSize}&offset=${offset}`;

                if (this.filterContextType) {
                    url += `&context_type=${encodeURIComponent(this.filterContextType)}`;
                }

                if (this.filterContextId) {
                    url += `&context_id=${encodeURIComponent(this.filterContextId)}`;
                }

                // Fetch conversations
                axios.get(url)
                    .then(response => {
                        if (response.data.status === 'success') {
                            this.conversations = response.data.conversations;
                            this.totalCount = response.data.total;
                        } else {
                            console.error('Error loading conversations:', response.data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading conversations:', error);
                    })
                    .finally(() => {
                        this.historyLoading = false;
                    });
            },

            // Load a specific conversation
            loadConversation(conversationId) {
                axios.get(`/agent/history/api/conversations/${conversationId}`)
                    .then(response => {
                        if (response.data.status === 'success') {
                            const conversation = response.data.conversation;
                            this.messages = conversation.messages;
                            this.currentConversationId = conversation.id;

                            // Set world ID if available
                            if (conversation.context_type === 'world' && conversation.context_id) {
                                this.selectedWorldId = conversation.context_id;
                                this.getGuidelines();
                            }

                            // Scroll to bottom of conversation
                            this.scrollToBottom();
                        } else {
                            console.error('Error loading conversation:', response.data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error loading conversation:', error);
                    });
            },

            // Refresh history
            refreshHistory() {
                this.loadConversations(this.currentPage);
            },

            // Delete a conversation
            deleteConversation(conversationId) {
                this.conversationToDelete = conversationId;
                this.deleteModal.show();
            },

            // Confirm delete
            confirmDelete() {
                if (!this.conversationToDelete) return;

                axios.delete(`/agent/history/api/conversations/${this.conversationToDelete}`)
                    .then(response => {
                        if (response.data.status === 'success') {
                            // Remove from list if successful
                            this.conversations = this.conversations.filter(c => c.id !== this.conversationToDelete);

                            // Reset current conversation if it was deleted
                            if (this.currentConversationId === this.conversationToDelete) {
                                this.resetConversation();
                                this.currentConversationId = null;
                            }

                            // Reload current page if now empty (unless it's page 1)
                            if (this.conversations.length === 0 && this.currentPage > 1) {
                                this.loadConversations(this.currentPage - 1);
                            }

                            // Update total count
                            this.totalCount--;
                        } else {
                            console.error('Error deleting conversation:', response.data.message);
                            alert('Error deleting conversation: ' + response.data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error deleting conversation:', error);
                        alert('Error deleting conversation. Please try again.');
                    })
                    .finally(() => {
                        // Close modal
                        this.deleteModal.hide();
                        this.conversationToDelete = null;
                    });
            },

            // Format date
            formatDate(dateString) {
                if (!dateString) return '';
                const date = new Date(dateString);
                return date.toLocaleString();
            },

            // Save conversation to database
            saveConversation() {
                // Reset form state
                this.saveTitle = '';
                this.saveError = null;

                // Generate default title if not specified
                if (this.selectedWorldId) {
                    const worldName = document.querySelector(`#world-select option[value="${this.selectedWorldId}"]`).textContent;
                    this.saveTitle = `${worldName} - ${new Date().toLocaleString()}`;
                } else {
                    this.saveTitle = `Conversation - ${new Date().toLocaleString()}`;
                }

                // Show modal
                this.saveModal.show();
            },

            confirmSaveConversation() {
                // Validate title
                if (!this.saveTitle.trim()) {
                    this.saveError = 'Please enter a title for this conversation';
                    return;
                }

                this.savingConversation = true;
                this.saveError = null;

                // Prepare data for API
                const data = {
                    conversation: {
                        title: this.saveTitle,
                        context_id: this.selectedWorldId || '',
                        context_type: 'world',
                        context_name: this.selectedWorldId ?
                            document.querySelector(`#world-select option[value="${this.selectedWorldId}"]`).textContent : ''
                    },
                    messages: this.messages.map(msg => ({
                        role: msg.role,
                        content: msg.content,
                        timestamp: new Date().toISOString()
                    }))
                };

                // Save via API
                axios.post('/agent/history/api/conversations/save', data)
                    .then(response => {
                        if (response.data.status === 'success') {
                            // Close modal and show success message
                            this.saveModal.hide();
                            alert('Conversation saved successfully!');

                            // Update conversation ID
                            this.currentConversationId = response.data.conversation_id;

                            // Refresh history
                            this.refreshHistory();
                        } else {
                            this.saveError = response.data.message || 'Failed to save conversation';
                        }
                    })
                    .catch(error => {
                        console.error('Error saving conversation:', error);
                        this.saveError = 'An error occurred while saving the conversation';
                    })
                    .finally(() => {
                        this.savingConversation = false;
                    });
            },

            initializeConversation() {
                // Initialize with a welcome message from the server
                this.messages = [
                    { role: 'assistant', content: this.welcomeMessage }
                ];
                this.currentConversationId = null;
            },

            sendMessage() {
                if (!this.inputEnabled || !this.userInput.trim() || this.isProcessing) return;

                // Add user message to conversation
                this.messages.push({ role: 'user', content: this.userInput });

                // Clear input and disable it while processing
                const userMessage = this.userInput;
                this.userInput = '';
                this.inputEnabled = true;
                this.isProcessing = true;
                this.promptOptions = [];

                // Scroll to bottom
                this.scrollToBottom();

                // Send message to API
                axios.post('/agent/api/message', {
                    message: userMessage,
                    world_id: this.selectedWorldId || null,
                    service: this.selectedService
                })
                    .then(response => {
                        if (response.data.status === 'success') {
                            // Add assistant response to conversation
                            this.messages.push({
                                role: response.data.message.role,
                                content: response.data.message.content
                            });

                            // Get new prompt options
                            this.getPromptOptions();

                            // This is a new conversation, no longer connected to history
                            this.currentConversationId = null;
                        } else {
                            // Add error message
                            this.messages.push({
                                role: 'assistant',
                                content: 'Sorry, there was an error processing your request.'
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error sending message:', error);
                        // Add error message
                        this.messages.push({
                            role: 'assistant',
                            content: 'Sorry, there was an error processing your request.'
                        });
                    })
                    .finally(() => {
                        // Re-enable input
                        this.isProcessing = false;
                        this.scrollToBottom();
                    });
            },

            selectPromptOption(option) {
                // Add selected option to conversation as user message
                this.messages.push({ role: 'user', content: option.text });

                // Clear prompt options and disable input while processing
                this.promptOptions = [];
                this.inputEnabled = true;
                this.isProcessing = true;

                // Scroll to bottom
                this.scrollToBottom();

                // Send to API
                axios.post('/agent/api/message', {
                    message: option.text,
                    world_id: this.selectedWorldId || null,
                    service: this.selectedService
                })
                    .then(response => {
                        if (response.data.status === 'success') {
                            // Add assistant response to conversation
                            this.messages.push({
                                role: response.data.message.role,
                                content: response.data.message.content
                            });

                            // Get new prompt options
                            this.getPromptOptions();

                            // This is a new conversation, no longer connected to history
                            this.currentConversationId = null;
                        } else {
                            // Add error message
                            this.messages.push({
                                role: 'assistant',
                                content: 'Sorry, there was an error processing your request.'
                            });
                        }
                    })
                    .catch(error => {
                        console.error('Error sending message:', error);
                        // Add error message
                        this.messages.push({
                            role: 'assistant',
                            content: 'Sorry, there was an error processing your request.'
                        });
                    })
                    .finally(() => {
                        // Re-enable input
                        this.isProcessing = false;
                        this.scrollToBottom();
                    });
            },

            // Generate prompt options/suggestions
            generateSuggestions() {
                if (!this.selectedWorldId || this.isFetchingSuggestions) return;

                this.isFetchingSuggestions = true;

                axios.post('/agent/api/suggestions', {
                    world_id: this.selectedWorldId,
                    service: this.selectedService
                })
                    .then(response => {
                        if (response.data.status === 'success') {
                            this.promptOptions = response.data.suggestions || [];
                        } else {
                            console.error('Error generating suggestions:', response.data.message);
                        }
                    })
                    .catch(error => {
                        console.error('Error generating suggestions:', error);
                    })
                    .finally(() => {
                        this.isFetchingSuggestions = false;
                    });
            },

            // Get prompt options from API
            getPromptOptions() {
                if (!this.selectedWorldId) return;

                axios.get(`/agent/api/prompt-options?world_id=${this.selectedWorldId}`)
                    .then(response => {
                        if (response.data.status === 'success') {
                            this.promptOptions = response.data.options || [];
                        } else {
                            console.error('Error getting prompt options:', response.data.message);
                            this.promptOptions = [];
                        }
                    })
                    .catch(error => {
                        console.error('Error getting prompt options:', error);
                        this.promptOptions = [];
                    });
            },

            // Reset conversation
            resetConversation() {
                // Initialize with welcome message
                this.initializeConversation();
                this.promptOptions = [];

                // Reset conversation state on server
                axios.post('/agent/api/reset')
                    .catch(error => {
                        console.error('Error resetting conversation:', error);
                    });
            },

            // MCP Integration Demo Methods
            testMcpTool(toolType) {
                this.mcpLoading = true;
                this.mcpResults = null;

                // Set loading text based on tool type
                const loadingTexts = {
                    'entities': 'Fetching ontology entities...',
                    'domain': 'Getting domain information...',
                    'sparql': 'Executing SPARQL query...'
                };
                this.mcpLoadingText = loadingTexts[toolType] || 'Processing MCP call...';

                // Make API call to test the MCP tool
                axios.post('/agent/api/test-mcp-tool', {
                    tool_type: toolType
                }, {
                    headers: {
                        'X-CSRFToken': document.querySelector('meta[name="csrf-token"]').content
                    }
                })
                    .then(response => {
                        if (response.data.status === 'success') {
                            this.mcpResults = {
                                tool: response.data.tool,
                                response_time: response.data.response_time,
                                data: response.data.data
                            };
                        } else {
                            this.mcpResults = {
                                tool: toolType,
                                response_time: response.data.response_time || 0,
                                data: `Error: ${response.data.message}`
                            };
                        }
                    })
                    .catch(error => {
                        console.error('Error testing MCP tool:', error);
                        this.mcpResults = {
                            tool: toolType,
                            response_time: 0,
                            data: `Network Error: ${error.message}`
                        };
                    })
                    .finally(() => {
                        this.mcpLoading = false;
                        this.mcpLoadingText = '';
                    });
            },

            clearMcpResults() {
                this.mcpResults = null;
            }
        }
    });
</script>
{% endblock %}